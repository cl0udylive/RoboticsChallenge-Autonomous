{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Self Driving Robot \n# \tAuthor:       Eli Weyer\n# \tCreated:      3/5/24\n# \tDescription:  Source code for a Self Driving Robot. \n#                 Created for New Visions Engineering \n#                 Robotics Challenge.\n#   Updated:      3/7/24\n# \n# ------------------------------------------\n\n# Import Random Library\nimport random\n\n# Calibrate Robot CPU\nbrain.screen.set_font(FontType.MONO15)\nbrain.screen.print(\"Calibrating\")\nbrain.screen.next_row()\nbrain.screen.print(\"Remain Still\")\nbrain.screen.next_row()\nbrain.screen.print(\"Approx. Time:\")\nbrain.screen.next_row()\nbrain.screen.print(\"5 Seconds\")\nbrain_inertial.calibrate()\nbrain_inertial.set_heading(0.0, DEGREES)\nbrain_inertial.set_rotation(0.0, DEGREES)\ncurrentHeading = brain_inertial.heading()\nwait(5, SECONDS)\n\nbrain.screen.clear_screen()\nbrain.screen.set_cursor(1, 1)\nbrain.play_sound(SoundType.TADA)\nbrain.screen.print(\"Complete!\")\nwait(2, SECONDS)\n\nbrain.screen.clear_screen()\nbrain.screen.set_cursor(1, 1)\n\n# Initialize and Calibrate Robot Sensors and Devices\ndrivetrain.set_stopping(HOLD)\ndrivetrain.set_heading(0.0, DEGREES)\ndrivetrain.set_rotation(0.0, DEGREES)\n\nbrain.play_note(4, 5, 500)\nbrain.screen.print(\"Devices:\")\nbrain.screen.next_row()\nbrain.screen.print(drivetrain)\nbrain.screen.next_row()\nbrain.screen.print(controller)\nbrain.screen.next_row()\nbrain.screen.print(distance_front)\nbrain.screen.next_row()\nbrain.screen.print(distance_left)\nbrain.screen.next_row()\nbrain.screen.print(distance_right)\nwait(3, SECONDS)\n\nbrain.screen.clear_screen()\nbrain.screen.set_cursor(1, 1)\n\n# Maze Challenge Logic\ndef handleSingleObstacle(isObstacleLeft):\n    if isObstacleLeft:\n        handleObstacle(\"left\")\n    else:\n        handleObstacle(\"right\")\n\ndef handleObstacle(obstacleDirection):\n\n    if obstacleDirection == \"front\":\n        brain.screen.print(\"Object Front!\")\n        print(\"Object Front!\")\n        drivetrain.stop()\n        sideSensorCheck()\n\n    elif obstacleDirection == \"left\":\n        brain.screen.print(\"Turning Right!\")\n        print(\"Turning Right!\")\n        drivetrain.set_turn_velocity(65, PERCENT)            \n        drivetrain.turn_for(RIGHT, currentHeading + 90, DEGREES, wait=True)\n\n    elif obstacleDirection == \"right\":\n        brain.screen.print(\"Turning Left!\")\n        print(\"Turning Left!\")\n        drivetrain.set_turn_velocity(65, PERCENT)\n        drivetrain.turn_for(LEFT, currentHeading + 90, DEGREES, wait=True)\n\n    elif obstacleDirection == \"both\":\n        print(\"Intersection!\")\n        drivetrain.stop()\n        randomTurn()\n\n    else:\n        print(\"Dead End!\")\n        drivetrain.stop()\n        randomTurn()\n\ndef randomTurn():\n\n    if random.choice([True, False]):\n        brain.screen.print(\"Turning Left!\")\n        print(\"Turning Left!\")\n        drivetrain.set_turn_velocity(65, PERCENT)\n        drivetrain.turn_for(LEFT, currentHeading + 90, DEGREES, wait=True)\n\n    else:\n        brain.screen.print(\"Turning Right!\")\n        print(\"Turning Right!\")\n        drivetrain.set_turn_velocity(65, PERCENT)\n        drivetrain.turn_for(RIGHT, currentHeading + 90, DEGREES, wait=True)\n\nDISTANCE_THRESHOLD = 100 # millimeters\nDRIFT_THRESHOLD = 5 # degrees\n\ndef mazeChallenge():\n    try:\n        while True:\n            distanceFront = distance_front.object_distance(MM)\n        \n            brain.screen.clear_screen()\n            brain.screen.set_cursor(1, 1)\n\n            while distanceFront < DISTANCE_THRESHOLD:\n                handleObstacle(\"front\")\n                break\n        \n            currentHeading = brain_inertial.heading()\n            nearestHeading = round(currentHeading / 90) * 90\n\n            if abs(currentHeading - nearestHeading) > DRIFT_THRESHOLD:\n                brain.screen.print(\"Adjusting Heading\")\n                print(\"Adjusting Heading\")\n                drivetrain.stop()\n                drivetrain.set_turn_velocity(65, PERCENT)\n                drivetrain.turn_to_heading(nearestHeading, DEGREES, wait=True)\n\n            brain.screen.print(\"Driving...\")\n            print(\"Driving...\")\n            drivetrain.set_drive_velocity(100, PERCENT)\n            drivetrain.drive(FORWARD)\n\n    except Exception as e:\n        brain.screen.print(\"Error!\")\n        brain.screen.next_row()\n        brain.screen.print(e)\n        print(\"Error! \", e)\n        \n\nmazeChallenge()\n\n##### Everything below this was made or edited by Thomas\n\ndef intersection():   # recursive function called everytime the robot comes across a intersection or dead end \n    openings = findOpenings() \n    wayBackHeading = brain_inertial.heading() - 180;  #heading is stored incase intersection is no good, is passed to goBack function Many need to be normalized to ensure it always falls between 0-360\n    openingHeading = wayBackHeading   #robot starts at the opening it came through and updates this var everytime it goes through a new opening \n\n    if mazecomplete():\n            return True;\n\n    if openings == 0:    #Logic is for dead ends, need to rename entire function to better describe it \n        goBack(wayBackHeading)\n        return False # goes back to last intersection and then takes one step out of recursive call \n            \n    for i in range(openings): #it will try every opening at an intersection\n        while objectFront():    \n            drivetrain.set_turn_velocity(65, PERCENT)\n            drivetrain.turn_to_heading(openingHeading +5, DEGREES, wait=True)       #Logic: spin to current angle - 180 and spin clockwise until first opening is found\n        openingHeading = brain_inertial.heading()\n        if driveForward():  #returns true when at a dead end or intersection which calls intersection\n            intersection() \n        if i == (openings -1): #If all paths in a intersection are bad go back and take one step out of recursive call \n            goBack(wayBackHeading)\n            return False\n    \n\n\ndef findOpenings():    #Basically does a circle and counts the amount of openings at a intersection, code is probably redundant but it works, hopefully \n    startHeading = brain.inertial.heading()\n    x = False                  \n    y = False\n    count = 0;\n    while brain.inertial.heading() != startHeading:\n        y = x\n        drivetrain.set_turn_velocity(65, PERCENT)\n        drivetrain.turn_to_heading(openingHeading +5, DEGREES, wait=True)\n        if objectFront() != True:\n            x = False\n        else \n            x = True\n\n        if x != y:\n            count += 1\n    return(count)\n\n\ndef goBack(wayBackHeading):\n    drivetrain.set_turn_velocity(65, PERCENT)\n    drivetrain.turn_to_heading(wayBackHeading, DEGREES, wait=True) #turns around to go back\n    driveForward();\n    \n\ndef driveForward(): #probably needs some sort of lane centering algorithm\n    while checkIntersection() != True:  #Function will return true when it comes across an intersection\n        drivetrain.set_drive_velocity(100, PERCENT)\n        drivetrain.drive(FORWARD)       #how do I control amount driven forward\n\n    \ndef checkIntersection():\n    if sideSensorCheck():\n        return True\n    if objectFront():\n        return True\n\n\ndef sideSensorCheck():   #Made by Eli but changed return values to work for me \n    DISTANCE_THRESHOLD = 100 # millimeters\n\n    distanceLeft = distance_left.object_distance(MM)\n    distanceRight = distance_right.object_distance(MM)\n\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n    if distanceLeft > DISTANCE_THRESHOLD and distanceRight > DISTANCE_THRESHOLD:\n        return True\n    \n    elif distanceLeft > DISTANCE_THRESHOLD or distanceRight > DISTANCE_THRESHOLD:\n        return True\n        \n    else:\n        return False\n\n\ndef objectFront():  #returns true if object is infront \n    distanceFront = distance_front.object_distance(MM)\n    if distanceFront < DISTANCE_THRESHOLD:\n        return True\n\n            \n\n\n\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}